\subsubsection*{Task} 
Check what types of indexes does Your DBMS support. Name and describe those of them which are especially useful for speeding up Your
queries.

Oracle 10g provides several indexing schemes
\footnote{\url{http://docs.oracle.com/cd/B19306_01/server.102/b14231/indexes.htm}}
that provide complementary performance functionality. These are:
\begin{itemize}
\item B-tree indexes: the default and the most common
\item B-tree cluster indexes: defined specifically for cluster
\item Hash cluster indexes: defined specifically for a hash cluster
\item Global and local indexes: relate to partitioned tables and indexes
\item Reverse key indexes: most useful for Oracle Real Application Clusters applications
\item Bitmap indexes: compact; work best for columns with a small set of values
\item Function-based indexes: contain the precomputed value of a function/expression
\item Domain indexes: specific to an application or cartridge.
\end{itemize}

A B-tree is a tree data structure that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time. It is designed to allow quickly finding those tuples that have a specific key value. For this reason, they are suitable for speeding up selection operations. 

We will use B-trees to index primary keys and other columns which are used to filter data.

Bitmap indexes are also designed for finding tuples by a specific key but are very structurally different from B-tree indexes. A bitmap index is like two-dimensional boolean arrays of the same size as the number of rows for every value where each element contains a binary value indicating whether the row contains this value. In this structure, the binary value takes up only 1 bit and for each possible value the number of rows bits are used. It is much more space efficient than B-trees if the number of possible values is very low. Another feature of bitmap indexes is the ability to quickly do index intersections.

In our data warehouse we have several columns which contain only a small set of possible values. By using bitmap indexes for these columns, it is possible to reduce the storage space taken up by the indexes. When a query filters data with several of these columns at the same time, the database system will combine these indexes to return data very quickly.


\subsection*{Task} 
For the chosen queries and their versions which use the materialized views,
implement indexes to improve their performance (You can try to evaluate
several strategies and choose the best one, e.g. best speed/size ratio).
Argue Your choice. Describe the overhead (index size, computation time,
index update costs, etc.) of implementing the chosen indexes

The following formulas to calculate the size of indexes are used: 
\begin{itemize}
    \item B-Tree index: $(NK*len(k)+NR*len(r))/(D*u)$ \footnote{
Shortcuts used: $NK$ = number of distinct key values, NR = 1000000 number of relations, len(k) = key length in kilobytes, len(r) = RID (disk page and location) length in kilobytes, D = 4096 disk page size in kilobytes, u = 1 fill factor for leaves}
    \item Bitmap index: $(NR/D*8)*NK$
\end{itemize}

\begin{lstlisting}[language=sql]
select l.country, sum(price * (1-discount) * quantity) revenue, 
  sum(quantity) subscriptions 
from oplatek.sub_subscription s 
join oplatek.sub_location l on s.keylocation = l.keylocation 
join oplatek.sub_date d on s.keydate=d.keydate and d.year=2010
group by l.country 
order by revenue desc
\end{lstlisting}

There should be B-tree indexes on $sub\_subscription$. $ keyLocation$ and $sub\_location.keyLocation$. Bitmap indexes are not suitable for this because there are many possible values and such a bitmap index would take up much more space.
\begin{itemize}
\item Index size: $(1000000*8+1000000*8)/(4096*1) = 21.48 MB$ (30.52 GB for bitmap indexes)
\item Computation time: $O(log n)$
\item Update cost:$O(log n)$
\end{itemize}

There should be an index of $(keyDate, year)$ on $sub\_date$. Assuming 365 days per year and 100 years $\rightarrow$ 36500 tuples. 36 thousands values is not considered a small set which would be suitable for bitmap. 
