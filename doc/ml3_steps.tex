\subsection{Android bugs preprocessing for Weka} % (fold)
\label{sub:Android bugs preprocessing for Weka}
\begin{itemize}
    \item We created csv files
    \item We ran unsuccessfully command
\begin{lstlisting}[language=sh]
$ java weka.core.converters.CSVLoader ANDROID_PLATFORM_BUGS.csv > ANDROID_PLATFORM_BUGS.arff
\end{lstlisting}
    \item so we design our own script
    \item  We tried tried to convert strings attributes to vectors for 1000 most important words. Unfortunately, following command crashes.
\begin{lstlisting}[language=sh]
    java weka.filters.unsupervised.attribute.StringToWordVector -i android-platform-bugs.arff -o android_plat-bugs-Vectors.arff
\end{lstlisting}
    \item We found out that the script works if there only the string attributes so we generated
    android-plat-strings.arff and android-plat-except-strings.arff
    \item We split them manually on the data part and the header.
    The headers we simply concatenated. On the data we applied following commands.
\begin{lstlisting}[language=sh]
nl -s " " -b a android-plat-except-strings.data # number lines
nl -s " " -b a android-plat-strings.data # number lines
sed s:\(......\) :\1 a : -f *except* > number-and-prefix-a
sed s:\(......\) :\1 b : -f *strings* > number-and-prefix-b
cat *strings* *except*> mixed.data
sort -n data > sorted.data
sed s:\n...... b :: -f sorted.data> joined-related-lines
sed s:...... a :: -f joined-related-lines > without-prefix
cat mixed-head without-prefix > android-plat-bugs2vectors.arff
\end{lstlisting}
    \item Next day we realised, that weka crashed because our attributes {\it status}, {\it type} or {\it id} were also generated by {\bf StringToWordVector} commnand, so we have multiple attributes with the same names. So instead of splitting in previous steps we just rename our attributes.
    \item Finally, we could run our example. We have had experienced that Weka requires much less memory if is launch from command line, so we had to find out parameters for command line first.
        \begin{itemize}
            \item We launch Weka
            \item Switched to Explorer
            \item Set up {\it Component} as label attribute for training and testing
            \item Choose 10 fold cross validation
            \item Choose Support Vector Machines (SMO)
            \item Copy parameters generated by GUI to command line
        \end{itemize}
    \item At the end we can ran a Weka command for training, testing and validating one of data mining algorithms 
\end{itemize}

\subsubsection{Weka datamining algorithms} % (fold)
\label{ssub:Weka datamining algorithms}

% subsubsection Weka datamining algorithms (end)



\begin{lstlisting}[language=sh]
    java weka.classifiers.functions.SMO -C 1.0 -L 0.0010 -P 1.0E-12 -N 0 -V -1 -W 1 -K "weka.classifiers.functions.supportVector.PolyKernel -C 250007 -E 1.0" -t sample-vectorised.arff -c 7> smo.out
\end{lstlisting}
    \item After 3:34:12 we got precision of 79\% on sample containing 4000 items with following accuracy and confusion matrix.
    Actually, as you can see the results are quite good because most of the misclassified samples are from category null.
    It can be perceived like that our classifier tried to classify them, where the people forget about it.

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p   &<-- classified as\\
45 & 9 & 1 & 1 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &  a = Browser\\
5&2138 & 34 & 52 & 19 & 0 & 9 & 10 & 9 & 15 & 3 & 0 & 1 & 0 & 0 & 0 &  b = null\\
0 & 65 & 17 & 12 & 1 & 0 & 2 & 6 & 1 & 4 & 1 & 0 & 0 & 0 & 0 & 0 &  c = Framework\\
0 & 75 & 6 & 38 & 4 & 0 & 0 & 6 & 2 & 4 & 0 & 0 & 0 & 0 & 0 & 0 &  d = Applications\\
0 & 47 & 1 & 2 & 54 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 &  e = Tools\\
0 & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &  f = User\\
1 & 18 & 1 & 0 & 1 & 0 & 32 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 &  g = Dalvik\\
1 & 38 & 4 & 5 & 0 & 0 & 0 & 18 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &  h = Google\\
0 & 35 & 5 & 3 & 0 & 0 & 0 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &  i = GfxMedia\\
0 & 33 & 3 & 10 & 1 & 0 & 0 & 2 & 0 & 15 & 0 & 0 & 0 & 0 & 0 & 0 &  j = Device\\
0 & 15 & 2 & 0 & 0 & 0 & 1 & 1 & 1 & 3 & 2 & 0 & 0 & 0 & 0 & 0 &  k = System\\
0 & 2 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &  l = Build\\
0 & 14 & 2 & 0 & 2 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 4 & 0 & 0 & 0 &  m = Web\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &  n = Market\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &  o = Android\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &  p = Docs\\
\end{tabular}

    \item We reran the experiment without null values in Component 

=== Stratified cross-validation ===

Correctly Classified Instances        3066               64.8203 %
Incorrectly Classified Instances      1664               35.1797 %
Kappa statistic                          0.597 
Mean absolute error                      0.1103
Root mean squared error                  0.2306
Relative absolute error                100.5597 %
Root relative squared error             98.478  %
Total Number of Instances             4730     


=== Confusion Matrix ===

   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   <-- classified as
 378   0  10   5  10   1   3   1   2   1   0   0   2   0   0   0 |   a = Browser
   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 |   b = null
   9   0 377  95  37   3  11  25  50  50  17   1  14   0   0   0 |   c = Framework
   8   0 153 580  17   4   5  55  24  33  12   1   2   0   0   0 |   d = Applications
   7   0  56  26 658   0  12   4   2   2   4   0  11   0   0   0 |   e = Tools
   0   0   9   8   1   6   0   3   3   1   0   0   0   0   0   0 |   f = User
   4   0  23   5  19   0 382   1   3   1   4   0   3   0   0   0 |   g = Dalvik
   2   0  54  78   4   1   0 262   6  19   9   0   1   0   0   0 |   h = Google
   6   0  70  27  14   0   9  10 163  34  17   0   4   0   0   0 |   i = GfxMedia
   0   0  60  58   7   0   1  19  46 138  28   0   3   0   0   0 |   j = Device
   3   0  35  29   9   2   7   7  14  23  27   0   1   0   0   0 |   k = System
   0   0   1   0  11   0   0   0   0   1   1   4   0   0   0   0 |   l = Build
   2   0  31   2  10   0   1   1   9   1   0   0  91   0   0   0 |   m = Web
   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 |   n = Market
   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0 |   o = Android
   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0 |   p = Docs

    \item In Another experiment we tried to deduce which owner should care about the bug.
    At first we ran the experiment with null values and got following results of Stratified 10 folds cross-validation

\begin{tabular}{|c|c|c|}
Correctly Classified Instances      & 3685  &            77.907  \\
Incorrectly Classified Instances    & 1045  &            22.093  \\
\end{tabular}

\begin{tabular}{|c|c|}
Kappa statistic                &         0.5353\\
Mean absolute error            &         0.019 \\
Root mean squared error        &         0.0972\\
Relative absolute error        &       184.3532 \\
Root relative squared error    &       136.7836\\
Total Number of Instances      &      4730   \\
\end{tabular}





% subsection Android bugs preprocessing for Weka (end)
